const gql = require('../src');
const loader = require('../loader');
const assert = require('chai').assert;

describe('gql', () => {
  it('parses queries', () => {
    assert.equal(gql`{ testQuery }`.kind, 'Document');
  });

  it('parses queries when called as a function', () => {
    assert.equal(gql('{ testQuery }').kind, 'Document');
  });

  it('parses queries with weird substitutions', () => {
    const obj = {};
    assert.equal(gql`{ field(input: "${obj.missing}") }`.kind, 'Document');
    assert.equal(gql`{ field(input: "${null}") }`.kind, 'Document');
    assert.equal(gql`{ field(input: "${0}") }`.kind, 'Document');
  });

  it('allows interpolation of documents generated by the webpack loader', () => {
    const sameFragment = "fragment SomeFragmentName on SomeType { someField }";

    const jsSource = loader.call(
      { cacheable() {} },
      "fragment SomeFragmentName on SomeType { someField }"
    );
    const module = { exports: undefined };
    eval(jsSource);

    const document = gql`query { ...SomeFragmentName } ${module.exports}`;
    assert.equal(document.kind, 'Document');
    assert.equal(document.definitions.length, 2);
    assert.equal(document.definitions[0].kind, 'OperationDefinition');
    assert.equal(document.definitions[1].kind, 'FragmentDefinition');
  });

  it('parses queries through webpack loader', () => {
    const jsSource = loader.call({ cacheable() {} }, '{ testQuery }');
    const module = { exports: undefined };
    eval(jsSource);
    assert.equal(module.exports.kind, 'Document');
  });

  it('parses single query through webpack loader', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      query Q1 { testQuery }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.equal(module.exports.kind, 'Document');
    assert.exists(module.exports.Q1);
    assert.equal(module.exports.Q1.kind, 'Document');
    assert.equal(module.exports.Q1.definitions.length, 1);
  });

  it('parses single query and exports as default', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      query Q1 { testQuery }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.deepEqual(module.exports.definitions, module.exports.Q1.definitions);
  });

  it('parses multiple queries through webpack loader', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      query Q1 { testQuery }
      query Q2 { testQuery2 }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.exists(module.exports.Q1);
    assert.exists(module.exports.Q2);
    assert.equal(module.exports.Q1.kind, 'Document');
    assert.equal(module.exports.Q2.kind, 'Document');
    assert.equal(module.exports.Q1.definitions.length, 1);
    assert.equal(module.exports.Q2.definitions.length, 1);
  });

  it('parses fragments with variable definitions', () => {
    gql.enableExperimentalFragmentVariables();

    const parsed = gql`fragment A ($arg: String!) on Type { testQuery }`;
    assert.equal(parsed.kind, 'Document');
    assert.exists(parsed.definitions[0].variableDefinitions);

    gql.disableExperimentalFragmentVariables()
  });

  // see https://github.com/apollographql/graphql-tag/issues/168
  it('does not nest queries needlessly in named exports', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      query Q1 { testQuery }
      query Q2 { testQuery2 }
      query Q3 { test Query3 }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.notExists(module.exports.Q2.Q1);
    assert.notExists(module.exports.Q3.Q1);
    assert.notExists(module.exports.Q3.Q2);
  });

  it('tracks fragment dependencies from multiple queries through webpack loader', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      fragment F1 on F { testQuery }
      fragment F2 on F { testQuery2 }
      fragment F3 on F { testQuery3 }
      query Q1 { ...F1 }
      query Q2 { ...F2 }
      query Q3 {
        ...F1
        ...F2
      }
    `);
    const module = { exports: undefined };
    eval(jsSource);

    assert.exists(module.exports.Q1);
    assert.exists(module.exports.Q2);
    assert.exists(module.exports.Q3);
    const Q1 = module.exports.Q1.definitions;
    const Q2 = module.exports.Q2.definitions;
    const Q3 = module.exports.Q3.definitions;

    assert.equal(Q1.length, 2);
    assert.equal(Q1[0].name.value, 'Q1');
    assert.equal(Q1[1].name.value, 'F1');

    assert.equal(Q2.length, 2);
    assert.equal(Q2[0].name.value, 'Q2');
    assert.equal(Q2[1].name.value, 'F2');

    assert.equal(Q3.length, 3);
    assert.equal(Q3[0].name.value, 'Q3');
    assert.equal(Q3[1].name.value, 'F1');
    assert.equal(Q3[2].name.value, 'F2');

  });

  it('tracks fragment dependencies across nested fragments', () => {
    const jsSource = loader.call({ cacheable() {} }, `
      fragment F11 on F { testQuery }
      fragment F22 on F {
        ...F11
        testQuery2
      }
      fragment F33 on F {
        ...F22
        testQuery3
      }

      query Q1 {
        ...F33
      }

      query Q2 {
        id
      }
    `);

    const module = { exports: undefined };
    eval(jsSource);

    assert.exists(module.exports.Q1);
    assert.exists(module.exports.Q2);

    const Q1 = module.exports.Q1.definitions;
    const Q2 = module.exports.Q2.definitions;

    assert.equal(Q1.length, 4);
    assert.equal(Q1[0].name.value, 'Q1');
    assert.equal(Q1[1].name.value, 'F33');
    assert.equal(Q1[2].name.value, 'F22');
    assert.equal(Q1[3].name.value, 'F11');

    assert.equal(Q2.length, 1);
  });

  it('correctly imports other files through the webpack loader', () => {
    const query = `#import "./fragment_definition.graphql"
      query {
        author {
          ...authorDetails
        }
      }`;
    const jsSource = loader.call({ cacheable() {} }, query);
    const oldRequire = require;
    const module = { exports: undefined };
    const require = (path) => {
      assert.equal(path, './fragment_definition.graphql');
      return gql`
        fragment authorDetails on Author {
          firstName
          lastName
        }`;
    };
    eval(jsSource);
    assert.equal(module.exports.kind, 'Document');
    const definitions = module.exports.definitions;
    assert.equal(definitions.length, 2);
    assert.equal(definitions[0].kind, 'OperationDefinition');
    assert.equal(definitions[1].kind, 'FragmentDefinition');
  });

  it('tracks fragment dependencies across fragments loaded via the webpack loader', () => {
    const query = `#import "./fragment_definition.graphql"
      fragment F111 on F {
        ...F222
      }

      query Q1 {
        ...F111
      }

      query Q2 {
        a
      }
      `;
    const jsSource = loader.call({ cacheable() {} }, query);
    const oldRequire = require;
    const module = { exports: undefined };
    const require = (path) => {
      assert.equal(path, './fragment_definition.graphql');
      return gql`
        fragment F222 on F {
          f1
          f2
        }`;
    };
    eval(jsSource);

    assert.exists(module.exports.Q1);
    assert.exists(module.exports.Q2);

    const Q1 = module.exports.Q1.definitions;
    const Q2 = module.exports.Q2.definitions;

    assert.equal(Q1.length, 3);
    assert.equal(Q1[0].name.value, 'Q1');
    assert.equal(Q1[1].name.value, 'F111');
    assert.equal(Q1[2].name.value, 'F222');

    assert.equal(Q2.length, 1);
  });

  it('does not complain when presented with normal comments', (done) => {
    assert.doesNotThrow(() => {
      const query = `#normal comment
        query {
          author {
            ...authorDetails
          }
        }`;
      const jsSource = loader.call({ cacheable() {} }, query);
      const module = { exports: undefined };
      eval(jsSource);
      assert.equal(module.exports.kind, 'Document');
      done();
    });
  });

  it('returns the same object for the same query', () => {
    assert.isTrue(gql`{ sameQuery }` === gql`{ sameQuery }`);
  });

  it('returns the same object for the same query, even with whitespace differences', () => {
    assert.isTrue(gql`{ sameQuery }` === gql`  { sameQuery,   }`);
  });

  const fragmentAst = gql`
  fragment UserFragment on User {
    firstName
    lastName
  }
`;

  it('returns the same object for the same fragment', () => {
    assert.isTrue(gql`fragment same on Same { sameQuery }` ===
      gql`fragment same on Same { sameQuery }`);
  });

  it('returns the same object for the same document with substitution', () => {
    // We know that calling `gql` on a fragment string will always return
    // the same document, so we can reuse `fragmentAst`
    assert.isTrue(gql`{ ...UserFragment } ${fragmentAst}` ===
      gql`{ ...UserFragment } ${fragmentAst}`);
  });

  it('can reference a fragment that references as fragment', () => {
    const secondFragmentAst = gql`
      fragment SecondUserFragment on User {
        ...UserFragment
      }
      ${fragmentAst}
    `;

    const ast = gql`
      {
        user(id: 5) {
          ...SecondUserFragment
        }
      }
      ${secondFragmentAst}
    `;

    assert.deepEqual(ast, gql`
      {
        user(id: 5) {
          ...SecondUserFragment
        }
      }
      fragment SecondUserFragment on User {
        ...UserFragment
      }
      fragment UserFragment on User {
        firstName
        lastName
      }
    `);
  });

  describe('fragment warnings', () => {
    let warnings = [];
    const oldConsoleWarn = console.warn;
    beforeEach(() => {
      gql.resetCaches();
      warnings = [];
      console.warn = (w) => warnings.push(w);
    });
    afterEach(() => {
      console.warn = oldConsoleWarn;
    });

    it('warns if you use the same fragment name for different fragments', () => {
      const frag1 = gql`fragment TestSame on Bar { fieldOne }`;
      const frag2 = gql`fragment TestSame on Bar { fieldTwo }`;

      assert.isFalse(frag1 === frag2);
      assert.equal(warnings.length, 1);
    });

    it('does not warn if you use the same fragment name for the same fragment', () => {
      const frag1 = gql`fragment TestDifferent on Bar { fieldOne }`;
      const frag2 = gql`fragment TestDifferent on Bar { fieldOne }`;

      assert.isTrue(frag1 === frag2);
      assert.equal(warnings.length, 0);
    });

    it('does not warn if you use the same embedded fragment in two different queries', () => {
      const frag1 = gql`fragment TestEmbedded on Bar { field }`;
      const query1 = gql`{ bar { fieldOne ...TestEmbedded } } ${frag1}`;
      const query2 = gql`{ bar { fieldTwo ...TestEmbedded } } ${frag1}`;

      assert.isFalse(query1 === query2);
      assert.equal(warnings.length, 0);
    });

    it('does not warn if you use the same fragment name for embedded and non-embedded fragments', () => {
      const frag1 = gql`fragment TestEmbeddedTwo on Bar { field }`;
      const query1 = gql`{ bar { ...TestEmbedded } } ${frag1}`;
      const query2 = gql`{ bar { ...TestEmbedded } } fragment TestEmbeddedTwo on Bar { field }`;

      assert.equal(warnings.length, 0);
    });
  });

  describe('unique fragments', () => {
    beforeEach(() => {
      gql.resetCaches();
    });

    it('strips duplicate fragments from the document', () => {
      const frag1 = gql`fragment TestDuplicate on Bar { field }`;
      const query1 = gql`{ bar { fieldOne ...TestDuplicate } } ${frag1} ${frag1}`;
      const query2 = gql`{ bar { fieldOne ...TestDuplicate } } ${frag1}`;

      assert.equal(query1.definitions.length, 2);
      assert.equal(query1.definitions[1].kind, 'FragmentDefinition');
      // We don't test strict equality between the two queries because the source.body parsed from the
      // document is not the same, but the set of definitions should be.
      assert.deepEqual(query1.definitions, query2.definitions);
    });

    it('ignores duplicate fragments from second-level imports when using the webpack loader', () => {
      // take a require function and a query string, use the webpack loader to process it
      const load = (require, query) => {
        const jsSource = loader.call({ cacheable() {} }, query);
        const module = { exports: undefined };
        eval(jsSource);
        return module.exports;
      }

      const test_require = (path) => {
        switch (path) {
        case './friends.graphql':
          return load(test_require, [
            '#import "./person.graphql"',
            'fragment friends on Hero { friends { ...person } }',
          ].join('\n'));
        case './enemies.graphql':
          return load(test_require, [
            '#import "./person.graphql"',
            'fragment enemies on Hero { enemies { ...person } }',
          ].join('\n'));
        case './person.graphql':
          return load(test_require, 'fragment person on Person { name }\n');
        default:
          return null;
        };
      };

      const result = load(test_require, [
        '#import "./friends.graphql"',
        '#import "./enemies.graphql"',
        'query { hero { ...friends ...enemies } }',
      ].join('\n'));

      assert.equal(result.kind, 'Document');
      assert.equal(result.definitions.length, 4, 'after deduplication, only 4 fragments should remain');
      assert.equal(result.definitions[0].kind, 'OperationDefinition');

      // the rest of the definitions should be fragments and contain one of
      // each: "friends", "enemies", "person". Order does not matter
      const fragments = result.definitions.slice(1)
      assert(fragments.every(fragment => fragment.kind === 'FragmentDefinition'))
      assert(fragments.some(fragment => fragment.name.value === 'friends'))
      assert(fragments.some(fragment => fragment.name.value === 'enemies'))
      assert(fragments.some(fragment => fragment.name.value === 'person'))
    });
  });

  // How to make this work?
  // it.only('can reference a fragment passed as a document via shorthand', () => {
  //   const ast = gql`
  //     {
  //       user(id: 5) {
  //         ...${userFragmentDocument}
  //       }
  //     }
  //   `;
  //
  //   assert.deepEqual(ast, gql`
  //     {
  //       user(id: 5) {
  //         ...UserFragment
  //       }
  //     }
  //     fragment UserFragment on User {
  //       firstName
  //       lastName
  //     }
  //   `);
  // });
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               smart-buffer  [![Build Status](https://travis-ci.org/JoshGlazebrook/smart-buffer.svg?branch=master)](https://travis-ci.org/JoshGlazebrook/smart-buffer)  [![Coverage Status](https://coveralls.io/repos/github/JoshGlazebrook/smart-buffer/badge.svg?branch=master)](https://coveralls.io/github/JoshGlazebrook/smart-buffer?branch=master)
=============

smart-buffer is a light Buffer wrapper that takes away the need to keep track of what position to read and write data to and from the underlying Buffer. It also adds null terminating string operations and **grows** as you add more data.

![stats](https://nodei.co/npm/smart-buffer.png?downloads=true&downloadRank=true&stars=true "stats")

### What it's useful for:

I created smart-buffer because I wanted to simplify the process of using Buffer for building and reading network packets to send over a socket. Rather than having to keep track of which position I need to write a UInt16 to after adding a string of variable length, I simply don't have to.

Key Features:
* Proxies all of the Buffer write and read functions.
* Keeps track of read and write positions for you.
* Grows the internal Buffer as you add data to it. 
* Useful string operations. (Null terminating strings)
* Allows for inserting values at specific points in the internal Buffer.
* Built in TypeScript
* Type Definitions Provided

Requirements:
* Node v4.0+ is supported at this time.  (Versions prior to 2.0 will work on node 0.10)


#### Note:
smart-buffer can be used for writing to an underlying buffer as well as reading from it. It however does not function correctly if you're mixing both read and write operations with each other.

## Breaking Changes with 2.0
The latest version (2.0+) is written in TypeScript, and are compiled to ES6 Javascript. This means the earliest Node.js it supports will be 4.x (in strict mode.) If you're using version 6 and above it will work without any issues. From an API standpoint, 2.0 is backwards compatible. The only difference is SmartBuffer is not exported directly as the root module.

## Breaking Changes with 3.0
Starting with 3.0, if any of the readIntXXXX() methods are called and the requested data is larger than the bounds of the internally managed valid buffer data, an exception will now be thrown.

## Installing:

`npm install smart-buffer`

or

`yarn add smart-buffer`

Note: The published NPM package includes the built javascript library. 
If you cloned this repo and wish to build the library manually use:

`tsc -p ./`

## Using smart-buffer

### Example

Say you were building a packet that had to conform to the following protocol:

`[PacketType:2][PacketLength:2][Data:XX]`

To build this packet using the vanilla Buffer class, you would have to count up the length of the data payload beforehand. You would also need to keep track of the current "cursor" position in your Buffer so you write everything in the right places. With smart-buffer you don't have to do either of those things.

```javascript
// 1.x (javascript)
var SmartBuffer = require('smart-buffer');

// 1.x (typescript)
import SmartBuffer = require('smart-buffer');

// 2.x+ (javascript)
const SmartBuffer = require('smart-buffer').SmartBuffer;

// 2.x+ (typescript)
import { SmartBuffer, SmartBufferOptions} from 'smart-buffer';

function createLoginPacket(username, password, age, country) {
    let packet = new SmartBuffer();
    packet.writeUInt16LE(0x0060); // Login Packet Type/ID
    packet.writeStringNT(username);
    packet.writeStringNT(password);
    packet.writeUInt8(age);
    packet.writeStringNT(country);
    packet.writeUInt16LE(packet.length - 2, 2);
    
    return packet.toBuffer();
}
```
With the above function, you now can do this:
```javascript
let login = createLoginPacket("Josh", "secret123", 22, "United States");

// <Buffer 60 00 1e 00 4a 6f 73 68 00 73 65 63 72 65 74 31 32 33 00 16 55 6e 69 74 65 64 20 53 74 61 74 65 73 00>
```
Notice that the `[PacketLength:2]` part of the packet was inserted after we had added everything else, and as shown in the Buffer dump above, is in the correct location along with everything else.

Reading back the packet we created above is just as easy:
```javascript

let reader = SmartBuffer.fromBuffer(login);

let logininfo = {
    packetType: reader.readUInt16LE(),
    packetLength: reader.readUInt16LE(),
    username: reader.readStringNT(),
    password: reader.readStringNT(),
    age: reader.readUInt8(),
    country: reader.readStringNT()
};

/*
{ 
    packetType: 96, (0x0060)
    packetLength: 30,
    username: 'Josh',
    password: 'secret123',
    age: 22,
    country: 'United States' 
};
*/
```

# Api Reference:

### Constructing a smart-buffer

smart-buffer has a few different ways to construct an instance. Starting with version 2.0, the following factory methods are preffered.

```javascript
let SmartBuffer = require('smart-buffer');

// Creating SmartBuffer from existing Buffer
let buff = SmartBuffer.fromBuffer(buffer); // Creates instance from buffer. (Uses default utf8 encoding)
let buff = SmartBuffer.fromBuffer(buffer, 'ascii'); // Creates instance from buffer with ascii encoding for Strings. 

// Creating SmartBuffer with specified internal Buffer size.
let buff = SmartBuffer.fromSize(1024); // Creates instance with internal Buffer size of 1024.
let buff = SmartBuffer.fromSize(1024, 'utf8'); // Creates instance with intenral Buffer size of 1024, and utf8 encoding. 

// Creating SmartBuffer with options object. This one specifies size and encoding.
let buff = SmartBuffer.fromOptions({
    size: 1024,
    encoding: 'ascii'
});

// Creating SmartBuffer with options object. This one specified an existing Buffer.
let buff = SmartBuffer.fromOptions({
    buff: buffer
});

// Just want a regular SmartBuffer with all default options?
let buff = new SmartBuffer();
```

## Backwards Compatibility:

All constructors used prior to 2.0 still are supported. However it's not recommended to use these.

```javascript
let writer = new SmartBuffer();               // Defaults to utf8, 4096 length internal Buffer.
let writer = new SmartBuffer(1024);           // Defaults to utf8, 1024 length internal Buffer.
let writer = new SmartBuffer('ascii');         // Sets to ascii encoding, 4096 length internal buffer.
let writer = new SmartBuffer(1024, 'ascii');  // Sets to ascii encoding, 1024 length internal buffer.
```

## Reading Data

smart-buffer supports all of the common read functions you will find in the vanilla Buffer class. The only difference is, you do not need to specify which location to start reading from. This is possible because as you read data out of a smart-buffer, it automatically progresses an internal read offset/position to know where to pick up from on the next read.

## Reading Numeric Values

When numeric values, you simply need to call the function you want, and the data is returned.

Supported Operations:
* readInt8
* readInt16BE
* readInt16LE
* readInt32BE
* readInt32LE
* readBigInt64LE
* readBigInt64BE
* readUInt8
* readUInt16BE
* readUInt16LE
* readUInt32BE
* readUInt32LE
* readBigUInt64LE
* readBigUInt64BE
* readFloatBE
* readFloatLE
* readDoubleBE
* readDoubleLE

```javascript
let reader = new SmartBuffer(somebuffer);
let num = reader.readInt8();
```

## Reading String Values

When reading String values, you can either choose to read a null terminated string, or a string of a specified length.

### SmartBuffer.readStringNT( [encoding] )
> `String` **String encoding to use**  - Defaults to the encoding set in the constructor. 

returns `String`

> Note: When readStringNT is called and there is no null character found, smart-buffer will read to the end of the internal Buffer.

### SmartBuffer.readString( [length] )
### SmartBuffer.readString( [encoding] )
### SmartBuffer.readString( [length], [encoding] )
> `Number` **Length of the string to read**

> `String` **String encoding to use** - Defaults to the encoding set in the constructor, or utf8.

returns `String`

> Note: When readString is called without a specified length, smart-buffer will read to the end of the internal Buffer.



## Reading Buffer Values

### SmartBuffer.readBuffer( length )
> `Number` **Length of data to read into a Buffer**

returns `Buffer`

> Note: This function uses `slice` to retrieve the Buffer.


### SmartBuffer.readBufferNT()

returns `Buffer`

> Note: This reads the next sequence of bytes in the buffer until a null (0x00) value is found. (Null terminated buffer)
> Note: This function uses `slice` to retrieve the Buffer.


## Writing Data

smart-buffer supports all of the common write functions you will find in the vanilla Buffer class. The only difference is, you do not need to specify which location to write to in your Buffer by default. You do however have the option of **inserting** a piece of data into your smart-buffer at a given location. 


## Writing Numeric Values


For numeric values, you simply need to call the function you want, and the data is written at the end of the internal Buffer's current write position. You can specify a offset/position to **insert** the given value at, but keep in mind this does not override data at the given position. This feature also does not work properly when inserting a value beyond the current internal length of the smart-buffer (length being the .length property of the smart-buffer instance you're writing to)

Supported Operations:
* writeInt8
* writeInt16BE
* writeInt16LE
* writeInt32BE
* writeInt32LE
* writeBigInt64BE
* writeBigInt64LE
* writeUInt8
* writeUInt16BE
* writeUInt16LE
* writeUInt32BE
* writeUInt32LE
* writeBigUInt64BE
* writeBigUInt64LE
* writeFloatBE
* writeFloatLE
* writeDoubleBE
* writeDoubleLE

The following signature is the same for all the above functions:

### SmartBuffer.writeInt8( value, [offset] )
> `Number` **A valid Int8 number**

> `Number` **The position to insert this value at** 

returns this 

> Note: All write operations return `this` to allow for chaining.

## Writing String Values

When reading String values, you can either choose to write a null terminated string, or a non null terminated string.

### SmartBuffer.writeStringNT( value, [offset], [encoding] )
### SmartBuffer.writeStringNT( value, [offset] )
### SmartBuffer.writeStringNT( value, [encoding] )
> `String` **String value to write**

> `Number` **The position to insert this String at**

> `String` **The String encoding to use.** - Defaults to the encoding set in the constructor, or utf8.

returns this

### SmartBuffer.writeString( value, [offset], [encoding] )
### SmartBuffer.writeString( value, [offset] )
### SmartBuffer.writeString( value, [encoding] )
> `String` **String value to write**

> `Number` **The position to insert this String at**

> `String` **The String encoding to use** - Defaults to the encoding set in the constructor, or utf8.

returns this


## Writing Buffer Values

### SmartBuffer.writeBuffer( value, [offset] )
> `Buffer` **Buffer value to write**

> `Number` **The position to insert this Buffer's content at**

returns this

### SmartBuffer.writeBufferNT( value, [offset] )
> `Buffer` **Buffer value to write**

> `Number` **The position to insert this Buffer's content at**

returns this


## Utility Functions

### SmartBuffer.clear()
Resets the SmartBuffer to its default state where it can be reused for reading or writing.

### SmartBuffer.remaining()

returns `Number` The amount of data left to read based on the current read Position.

### SmartBuffer.skip( value )
> `Number` **The amount of bytes to skip ahead**

Skips the read position ahead by the given value.

returns this

### SmartBuffer.rewind( value )
> `Number` **The amount of bytes to reward backwards**

Rewinds the read position backwards by the given value.

returns this

### SmartBuffer.moveTo( position )
> `Number` **The point to skip the read position to**

Moves the read position to the given point.
returns this

### SmartBuffer.toBuffer()

returns `Buffer` A Buffer containing the contents of the internal Buffer.

> Note: This uses the slice function.

### SmartBuffer.toString( [encoding] )
> `String` **The String encoding to use** - Defaults to the encoding set in the constructor, or utf8.

returns `String` The internal Buffer in String representation.

## Properties

### SmartBuffer.length

returns `Number` **The length of the data that is being tracked in the internal Buffer** - Does NOT return the absolute length of the internal Buffer being written to.

## License

This work is licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {"version":3,"file":"cross-fetch.js","sources":["../node_modules/whatwg-fetch/fetch.js"],"sourcesContent":["(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bod